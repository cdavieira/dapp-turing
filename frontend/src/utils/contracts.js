import TuringContractArtifact from './../TuringToken.json';
import { ethers, parseEther } from 'ethers';

const turing_abi = TuringContractArtifact.abi;

class TuringContractProxy {
  /* Mapping: addr -> account (addr is in lowercase)
   *
   * Mapping for fast retrieval of 'accounts'.
   * 'accounts' itself is an array, so it's not good for this sort of thing.
   *
   * All operations which 'write' to the blockchain are mirrored in this
   * structure.
   *
   * Therefore, this structure might store a 'dirty'/'uncommited' version of
   * the associated blockchain.
   *
   * The 'commit' method takes care of checking which accounts have pending
   * transactions, marking those accordingly in this process.
   *
   * Thus, accounts which aren't in sync with the blockchain will have the
   * prop 'transaction_ongoing' equal to True.
   * */
  #local = new Map();

  /* Container of all transactions generated by 'issueToken' and 'vote'.
   *
   * Whenever the events associated with these transactions are handled, these
   * transactions get deleted from this container.
   *
   * Before commiting, all accounts with pending transactions are flagged with
   * 'transaction_ongoing = true', meaning that these transactions haven't
   * been added to the blockchain yet.
   * */
  #unconfirmed_transactions = new Map();

  #senderAddr = null; //actually a promise, be careful

  constructor(addr, signer, accounts){
    //https://docs.ethers.org/v6/api/contract/#BaseContract
    this.base = new ethers.Contract(addr, turing_abi, signer);
    this.addListeners();
    this.#senderAddr = signer.getAddress();
    accounts.forEach((account) => {
      let key = account.addr.toLowerCase();
      this.#local.set(key, account);
    });
  }

  async balanceOf(acc){
    try{
      const value = await this.base['balanceOf'](acc);
      console.log(value);
      return value;
    }
    catch(err){
      console.log(err);
    }
  };

  async issueToken(codename, turingAmount){
    try{
      turingAmount = parseEther(turingAmount);

      const transactionData = await this.base['issueToken'](codename, turingAmount);
      this.#unconfirmed_transactions.set(transactionData.hash, transactionData)

      const receiverAddr = (await this.base['getAccountAddress'](codename)).toLowerCase();
      const receiver = this.#local.get(receiverAddr);

      receiver.last_update = new Date();
      receiver.amount += turingAmount;
    }
    catch(err){
      console.log(err);
    }
  }

  async vote(codename, turingAmount){
    try{
      turingAmount = parseEther(turingAmount);

      const transactionData = await this.base['vote'](codename, turingAmount);
      // console.log(transactionData);
      this.#unconfirmed_transactions.set(transactionData.hash, transactionData)

      const receiverAddr = (await this.base['getAccountAddress'](codename)).toLowerCase();
      const receiver = this.#local.get(receiverAddr);
      const senderInc = BigInt('200000000000000000');
      const senderAddr = (await this.#senderAddr).toLowerCase();
      const sender = this.#local.get(senderAddr);

      receiver.last_update = new Date();
      receiver.amount += turingAmount;
      sender.last_update = new Date();
      sender.amount += senderInc;
    }
    catch(err){
      console.log(err);
    }
  }

  async votingOn(){
    try{
      await this.base['votingOn']();
    }
    catch(err){
      console.log(err);
    }
  }

  async votingOff(){
    try{
      await this.base['votingOff']();
    }
    catch(err){
      console.log(err);
    }
  }

  async getAccountAddress(codename){
    try{
      return await this.base['getAccountAddress'](codename);
    }
    catch(err){
      console.log(err);
    }
  }

  async getContractAddress(){
    return await this.base.getAddress();
  }


  /* Staging */

  #tokenIssuedHandler(senderAddr, receiverAddr, amountReceived, data){
    const transactionData = data.log;
    const hash = transactionData.transactionHash;
    console.log(`TokenIssued Event (hash ${hash}):`, senderAddr, 'has sent', amountReceived, 'saTurings to', receiverAddr);

    if(this.#unconfirmed_transactions.delete(hash) === true){
      console.log(`Transaction ${hash} has been removed from the list of pending transactions`);
    }
    else{
      console.log(`ERROR: Transaction ${hash} hasn't been removed from the list of pending transactions`);
    }
  }

  #voteHandler(voterAddr, votedAddr, amountReceived, data){
    const transactionData = data.log;
    const hash = transactionData.transactionHash;
    console.log(`Voted Event (hash ${hash}):`, voterAddr, 'has voted with', amountReceived, 'saTurings for', votedAddr);

    if(this.#unconfirmed_transactions.delete(hash) === true){
      console.log(`Transaction ${hash} has been removed from the list of pending transactions`);
    }
    else{
      console.log(`ERROR: Transaction ${hash} hasn't been removed from the list of pending transactions`);
    }
  }

  async addListeners(){
    await this.base.on(this.base.getEvent('TokenIssued'), this.#tokenIssuedHandler.bind(this));
    await this.base.on(this.base.getEvent('Voted'), this.#voteHandler.bind(this));
  }

  async removeListeners(){
    await this.base.off(this.base.getEvent('TokenIssued'));
    await this.base.off(this.base.getEvent('Voted'));
  }



  /* local database management */

  async poll(){
    //NOTE: 'forEach' fails, because the async callback makes all elements of
    //'#local' become unresolved promises
    for(const account of this.#local.values()) {
      account.amount = await this.base.balanceOf(account.addr);
    }
  }

  commit(){
    let account;
    let transId;

    this.#local.forEach((acc, _) => {
      acc.transaction_ongoing = false;
    });

    this.#unconfirmed_transactions.forEach((trans, _) => {
      console.log(trans);
    });

    this.#unconfirmed_transactions.forEach((trans, _) => {
      transId = trans.from.toLowerCase();
      if(this.#local.has(transId)){
	account = this.#local.get(transId);
	account.transaction_ongoing = true;
      }
      transId = trans.to.toLowerCase();
      if(this.#local.has(transId)){
	account = this.#local.get(transId);
	account.transaction_ongoing = true;
      }
    });

    const accounts = Array.from(this.#local.values());
    return accounts;
  }
}

export { TuringContractProxy };
